# Stage 1: Build the ASP.NET Core application
FROM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS build
WORKDIR /src

# Copy the backend project file and restore dependencies.
# This improves caching: if only the csproj changes, NuGet packages are restored faster.
COPY backend/*.csproj ./backend/
RUN dotnet restore backend/backend.csproj

# Copy the rest of the backend source code
COPY backend/. ./backend/
WORKDIR /src/backend

RUN dotnet tool install --global dotnet-ef
ENV PATH="${PATH}:/root/.dotnet/tools"

RUN mkdir -p /app/publish
RUN dotnet ef migrations bundle --self-contained -r linux-musl-x64 --output /app/publish/efbundle --verbose

# Publish the application for production
# -c Release: Builds in Release configuration
# -o /app/publish: Publishes output to /app/publish inside the container
# /p:UseAppHost=false: Prevents creation of a native executable, makes it smaller and self-contained within dotnet runtime.
# --no-restore: Skips restoring packages again, as they were restored in an earlier step.
RUN dotnet publish "backend.csproj" -c Release -o /app/publish /p:UseAppHost=false

# Stage 2: Create the runtime image
# Using a smaller ASP.NET runtime image for the final production container
FROM mcr.microsoft.com/dotnet/aspnet:8.0-alpine AS final
WORKDIR /app

# Expose the port your ASP.NET Core app will listen on.
# ASP.NET Core applications running in the dotnet/aspnet base image typically listen on port 80 by default.
EXPOSE 80

# Copy the published application from the build stage to the final image
COPY --from=build /app/publish .

RUN chmod +x ./efbundle

# Set the entry point for the container: execute the published DLL
ENTRYPOINT ["sh", "-c", "./efbundle && dotnet backend.dll"]

