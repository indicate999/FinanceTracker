# Stage 1: Build the ASP.NET Core application
FROM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS build
WORKDIR /src

# Copy the backend project file and restore dependencies.
# This improves caching: if only the csproj changes, NuGet packages are restored faster.
COPY backend/*.csproj ./backend/
RUN dotnet restore backend/backend.csproj

# Copy the rest of the backend source code
COPY backend/. ./backend/
WORKDIR /src/backend

# Publish the application for production
# -c Release: Builds in Release configuration
# -o /app/publish: Publishes output to /app/publish inside the container
# /p:UseAppHost=false: Prevents creation of a native executable, makes it smaller and self-contained within dotnet runtime.
# --no-restore: Skips restoring packages again, as they were restored in an earlier step.
RUN dotnet publish "backend.csproj" -c Release -o /app/publish /p:UseAppHost=false

# Stage 2: Create the runtime image
# Using a smaller ASP.NET runtime image for the final production container
FROM mcr.microsoft.com/dotnet/aspnet:8.0-alpine AS final
WORKDIR /app

# Expose the port your ASP.NET Core app will listen on.
# ASP.NET Core applications running in the dotnet/aspnet base image typically listen on port 80 by default.
# If your Program.cs explicitly configures Kestrel to listen on a different port (e.g., UseUrls("http://*:8080")), adjust this.
EXPOSE 80

# Copy the published application from the build stage to the final image
COPY --from=build /app/publish .

# Set the entry point for the container: execute the published DLL
ENTRYPOINT ["dotnet", "backend.dll"]
